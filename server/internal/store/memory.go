package store

import (
	"sync"
	"time"

	"mahi/server/internal/auth" // uses Argon2id helpers (HashPassword/VerifyPassword)
)

// Domain model returned to API callers (no password field here)
type User struct {
	ID    string `json:"id"`
	Email string `json:"email"`
	Name  string `json:"name,omitempty"`
}

// Internal record keeps the hashed password
type userRecord struct {
	User
	pwHash string // argon2id hash generated by auth.HashPassword
}

type refreshRow struct {
	UserID string
	Exp    time.Time
}

type Memory struct {
	mu      sync.Mutex
	users   map[string]userRecord // id -> userRecord
	byEmail map[string]string     // email -> id

	// refresh token store (rotation): refresh -> { userID, exp }
	refresh map[string]refreshRow
}

func NewMemory() *Memory {
	m := &Memory{
		users:   map[string]userRecord{},
		byEmail: map[string]string{},
		refresh: map[string]refreshRow{},
	}

	// Seed one demo user: demo@demo.com / password
	pw, _ := auth.HashPassword("password")
	u := userRecord{
		User: User{
			ID:    "u_1",
			Email: "demo@demo.com",
			Name:  "Demo User",
		},
		pwHash: pw,
	}
	m.users[u.ID] = u
	m.byEmail[u.Email] = u.ID

	return m
}



// CreateUser creates a new user if the email is not taken.
// It does NOT set a password; call SetPassword next.
func (m *Memory) CreateUser(email, name string) (User, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if _, exists := m.byEmail[email]; exists {
		return User{}, ErrEmailExists
	}

	// naive id generator for demo; replace with ULIDs/UUIDs in real DB
	id := "u_" + time.Now().UTC().Format("20060102150405.000000000")

	rec := userRecord{
		User: User{
			ID:    id,
			Email: email,
			Name:  name,
		},
		pwHash: "",
	}
	m.users[id] = rec
	m.byEmail[email] = id
	return rec.User, nil
}

// SetPassword hashes and stores the password for a user id.
func (m *Memory) SetPassword(userID, plain string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	rec, ok := m.users[userID]
	if !ok {
		return ErrUserNotFound
	}
	hash, err := auth.HashPassword(plain)
	if err != nil {
		return err
	}
	rec.pwHash = hash
	m.users[userID] = rec
	return nil
}

// VerifyCreds checks email + password against the stored Argon2id hash.
func (m *Memory) VerifyCreds(email, password string) (User, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	id, ok := m.byEmail[email]
	if !ok {
		return User{}, ErrInvalidCreds
	}
	rec := m.users[id]
	if rec.pwHash == "" || !auth.VerifyPassword(password, rec.pwHash) {
		return User{}, ErrInvalidCreds
	}
	return rec.User, nil
}

func (m *Memory) GetUser(id string) (User, bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	rec, ok := m.users[id]
	return rec.User, ok
}

// ---- Refresh token management (unchanged) ----

func (m *Memory) SaveRefresh(token, userID string, exp time.Time) {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.refresh[token] = refreshRow{UserID: userID, Exp: exp}
}

func (m *Memory) RotateRefresh(old string, newToken string, userID string, exp time.Time) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	row, ok := m.refresh[old]
	if !ok || row.UserID != userID || time.Now().After(row.Exp) {
		return ErrRefreshInvalid
	}
	delete(m.refresh, old)
	m.refresh[newToken] = refreshRow{UserID: userID, Exp: exp}
	return nil
}

func (m *Memory) LookupRefresh(token string) (string, time.Time, bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	row, ok := m.refresh[token]
	return row.UserID, row.Exp, ok
}

func (m *Memory) DeleteRefresh(token string) error {
    m.mu.Lock(); defer m.mu.Unlock()
    delete(m.refresh, token)
    return nil
}
